<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
    <link rel="icon" href="/assets/knoxramsey_logo.jpeg" type="image/jpeg">
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"986de5af306f910e7eb39051becf0bd038e5544e4c216a8d7b93c45ee03f4a6e47aa1b90f0fe025f6ecf940544b1b0a8778259ac9d93a1cd44d8acff794e34e820b0088351ef7b01c8c41d13106647d5e072903c487e3256f43477a3fa2f9e0bc6b3fce107996f12d8ac88355424c9d48f324b9a82edede4c65aba05e763e56f45e80fd62119a960c6c4629f5dfa94d3852a8e6629b49a67a920789d7ce7168079ece10ea975ad0cd0ace3dafafa831f4a3f11835ec26777269d9857d23f7aead47a436cf9c3d223f3cf1a50c4646cf733f26324654f3f179cb39f22e72d1e4441b38c06e2e280ff458d25140075b0d7f466a371164ded95f9515ddcacf7ba35bd29cb2f49b9e35541c3cc4df898730f87c7a5d0e76826b413fcc7a88db5360c3bbcae9e7522020696acaf23a32c3dad1480f180a6ee1bae65f93adfa5413996ae2dca4189b24d9cd21c38a23146526ad6315a61cbf4d32c2ab9d60eada713b0ab6f7b2f20c5bc69d659ee3ed6c153053e68f13dce5d95ecfbf0fc24c2a1503a8a493bb52ba59380505376e90608205df50c4b6afd0bc0c991d9331aad7cef6c95e777785773a56d1d8ef5c758d05c55d5e8adaf8e7da046b7e58d53ea8110cd49a9567df14e3c20613bbad657891c0963afe5153fa7dbdadfdcb4221e1ef486a61073152f616689f1fbeee23b6953318eae15a55e11fcd87b1b9ae56a7515d067ddda1f3202423cb7c3e197b39872ce0a1ff7fb5a5d74d256f97bb6a20449adcd0ce9a1350513b9807c2ee3bede16e33f8e4a12bee4dda68b6373dc3b229b25ee89d7b3526d7d7050a25df482f0cbbae6c760c8407f88cbcabfe6f4902e11c1a19b2d8c89033b0d60818a316ea5bb98b9f7cfe65c742b4d8c588a1877dd09af9e3f0ca8c3fa746a768995f0e2c5a2e697ab2fd77bfde58c9d1bbda12539bcac85a6bf0b64d866d4919023b21cdff40c5e9e331d49a94d4b51807354ff774afbe911f5ecdc0fc12b2d51b75084ec90ef45b594888c7b86d424a5ffe5f229ad4898c39c88fbd1fc956dfd41e8dfc8b2d5368c1f69b2ca33f24dd048625d42e60b3fb56a866689a3c5dc52c484f46f813dbe66a90f2ed5f20de564f2c8dd0a4658a4aebdae2116698f1f71109d8a57815e84457a7eb82f94c8f1b8c78c6b5c87ad897e69a31ea8cde3bc28ab46a59cbb6084f8d5fed07a98bfa5aa3c923fbbd0bfb27ef2e0cc5db899b3e43eb02d2084c5b159ea544cc41ea45efa1c5374a4088fdbed7060e42a87dc9adc7880084fc3014e8f26d87349e6f40e3fb5b188bc95441df67337f915db3f83ba5e38b4142fa069f7d2d34e9394097d879a9a69c2324b6f01d10ef8d909704fae3881f9d0c27b1bad12914a379c72860cb8551cbffb2b78f6f9c02cfb8fbd0a4d641cf978b49f18be108dc36321c1e467c3d7a6dc663baa2b43eb48842b494c9d8468bd93b92226d620305962a89b7a74fecb6a8087bec9cda5b9388f9ad5817d87fc03b4e48e808e7a5acec8c696891173b078965d76c0812f4fb210c9ce6812e146a3743f75ea968c59a165783ca8322a7a51e6efa61d7ee7aac6b1fea57b4989a096a8e54725232d38acd4d38e072914ef5313ea83444814a500b497c481a73b4936ff6d527d49e8d5a10fcad15397e647aa2815f1f450238c0f6d1fd66a526f42b72683429f743533892df0ea5e3a3340e4433bf94c0b6351d5b949d0e05e7f0e0eeade960b9a3b5e55f8035faec492e5efce4af8ff9b8eae3e38ace015bb69d9d7163036cb97656b802185683f7212a97c01228e35b9e48d6e77fc586b753a126b2cc0e811634eee2ac1df2ec653ecdeb1d39d38d7bf57ab942dac5ef21c8a05b573576f3473aea096afae4bafcfddbce13daf75c7445f4fa9e4764a7c219012ae6a222ec5a0b20da10c51d1c52db00f5dcbe5da6b8baed412b8dca0a0d0e85ccd51f4a2e500bfe7f7c1b48b20b788ffd0a480b621b2266351852956ee784fee49a684d25f53a9ee123d5be0b71af508dafd0e0f4b39350cc4b2bebb135a2b95d81a4e6947ca57b3f27e3f1b664016c00539008012169980035f27626ffba1ed8451fc681f1bec378a72bc41c96e89ef810aede809107dd453bfe8616efb0231a890033bb93c46857d0308a4495db520e409eb73cfe00b894ad78f66bf515037a2983a334d6ac6f7be9292cc841b2e8108e33a2e44808eb405f68663bd6ea17d11c34bee956c2955762b2c074aa0425db9c29033fc5e12225c05d477a86958fc06011f1ea1f05f0bff0a64336dd91a7567583a99bfd8cd573cea45dd58cd10733a01dc5533265057cff6ae8640d2d7727e403d94b8727727a03f6a1327d3d71c72f49df46e36cf412a038f06eab9ad94cb65a4cf92889e6ac0b5854ecef01e565474d2f486764d094d4e0cd9e2fa572b8880ed227c090a274ff1b3196923c18254d1d0c935fddde22165cfe5d4820df473e955031ca3bb8d5e174609215655c824b80cbd93c5a99f61b788c19cace6c68a2958ff30483a91bf714e9a9f1a600a9e9700d9be4cfb5570b3ac2981e924350d1ac045b57814839a45911a99dd4e34409f9057c91f5517274c08d9dfd15913a80d9f3ce7f69fa5f4474d2fb7623710b12a4ec9c947a30c01b2da6b885f6a1766e34d7059eb96cd273d9451bf9858d4aba66e3e7908adaa8223fd9f0330b409e404b9f9b344a51f5f7793fab87c10f540c703fbda68182a003d1d0d337d713c9429c20a9d348c7bf919d9f888351104d05f7bd6725e67aaf5e71fe411e1d7c8dd0c4f9691393af507e0c96da97285c1ae549d52ed46719984e415d0656cf8128bd04e852de9569595a55c0a97e0077af1d4c9ca9ecaba8af46f08ee38658f23da5e807e82d9b607ac169b0e4c937f8dbd0c8a3aaec5193f23aabea837d0c4ed882f8dae4c2c09a3f7e6e161673b6109b543e80d7f29c96e3525ae8b9ebcee3fd090d4f403a0d3c2d80eb2d63afa413ec0d667de8a42dc8003b83cac62e803839d399c861895661c1db4c3dca9687ddcf7747db635ff635462592a634dad9037fe17267ba8640dbbb53fe420bd34deebe3596b7e865cc733fe755b94e09aebfe583148ea02c0e61bd846abbc3ab2966cd5a3e304a8a25ccb9876738aae8e5ee39f058dad5a36578d43ce0ef879b04e2e240ebe01dacd2bd765d81190ea00a98bf8fe050f6e09f1cce4e41dd48ed7e3da77573e7bc2533c72eb8febaedb08535cdba3013e87580d57c5a8ecde40e65c01a75868dc336f40ea8f0045ae2fa8dbc09d490426d9350591a06ec23248c42547f0c01a48fa239c57322f58c5ffa7982ce6b7de38dde3eaa11eb186abd6f5a978ddb4f19eed0de8836ff86653f0553b9c957ce661f95e1cd7cf268094be3645522c30501e7f2c7dad796e18a8e8b4832c0463543ba345e0d1fb159ad4127a9c7c77838e0b2672c33403fc9bc32642818d2286debc3d5275e563ce781ddce7a70b65fce716e4c9305239b157a96239bf6a49dec702b50371126ff180d07f4a2eb7432d59267bcf646c6730a6e670b387f72c50e1feba18a6592bb727b38212f3ea87bcea6417ece72c450fd8407077920f1dc8e338463108158db568a9f1b84594231635558c4cd598a6c4cd1e0a63e5435a3aefb75644c5fd94b8072113509058fc2fcbcbc330d056ab61b7ef5f5c4b8ce9b57b094506d702a114c7d31bbb0f2a9b54b535321faeedd3a0f3d87f91089a2f1acde8cec2e8eaa2f5bd19878402074b77cbe292416e07a0333e4d5236a026b40d307b5edf19dc4172e47dcca8712f02ff0b6f8d5d7a31343990e4f4a5e48e5d59d2f8dedee45bb3ab90cb6dcacc0c39b9b6a3a3a19ad033404d704e75ee7967178d860fe3d8bfcb060e5908b293d0f170547950cf954b5f62e4970eb3667ce33187270720ebdeae9fc99c9d1a1de2d30e2d4152b09ed8a0be9a2085712ca03afd0ebc634d0a039bd8e1bb3de80b24ffa2fa0774c481a85f4dbddb4d754805836700d94848b9b57bbbbac9dfceeb453473a3043d23ca5e38354d949161f8a060ecc4031dca814ea9fe8c9d725cde8284987368cbc2b6db4a198badc59d358e7f83af11fc4ec284381a63b0615251cc274e22e9fc45d336280dfd6a8a1ace1423973f90d3291ba540fda599309c5f02c016d2b254ee24f1be1886db5e962d603e85089740019bf7a5b42df410d234e7d46fc6336b371468d04d10d28f21db25627adc41e8eb58048991c28e4e36ad6fb391bf1a5fa52cc48b0bec9fadaae9066818ebf8c1cc70c5a040d94d86cd856147e2fb4ba9d3472b5aaac8bf20824bc8d2dee61199c839e24a36dcfcc48d018a95b8fdf0148fc90d5fcd9f9fea0e44de541dc1381f9372512bfeaba043e7ac0aaed7db603ad3098d477d6dc32c7e7d7c042a996edb49093a1d8a90307a76e5b2d7d72296a709f2096d455cb21b419a7a1b77d10bda364f0f8f6de9ee03fc2f4fcc774c110e138c1ad100d2d19aff58cf321d8b59bd6146d9b871dda7f11350880be0e1dc764d3c349b43586bc4546118ba04c9504f804a11bc0ebb0ba96ea7fa1813f861d0e1eed235faf6fa7562ef9f22f46a75fe53a4ee36e8c6d9654b657ba3458cf28b22b58e3e13ad7f33f33904583886a40ab5c2c414896565a2734d9804182081808af3d107db90f37d226eab0009b26957260080cee0fa102dd24909c6a2444fa42e3ce99832f2431e6ba90e8c51bda68ee7e105519977ac4f0eeef5253cd221e495fd9762bac76b8116284fdb681ba6a3cef5647b662697b109009040740b3362757f62832e1ac04412f030f69f2c5c3f3b0299cf7d69ea1deb99c41501487c465f5ec7e19aa36c255a2eecda88b58ada500d443e98df8550a13776585c530af79765fbae69f24f5a445587291080ecab0e2a5a92a3e863320c655b1b8dcc8460735189ba93e8a0b3781075bc6d6b312dac4ccc17d14ae3071325c1da92349571869f354ee9c3dc57eac576137acc0f1ef94c081844f574e76c9b36e8d02bb4686dc9d99b7e9cef2d1b720677b8d3ec29ae5a6eaf91d0684d313ae0d994eda10e79a7d7e4f33f871c12afe316b0743775ce88bd70cc239bbb4ddc99b5c846f4e97cf0717914f8d9ac1e728c4f47d13e900f5fb5912e3beac11bdf8913f9d24bd80d970e2ded27c48b600907b92bc57fbef96845c5f340efa59a70e9f75a4934ec515e32a002094cea6956610f4ca8665dbaf08611b955edecb34a537e0d4b55395d2f7142860d94436308c3261ee3766a0f2dce1a531c6098138fdcc02e8c3ddd01c8f19523e84580a62313c4d0d665c69d45174d8bd0e029a6d93fb8a4066c378f5e586b3e0168fb76056b27dcf600de1819f3a815ad1c8724f19ff80bbbbaaa9bedb3b4e16915764c33528ba532eac6092d4a45158ba0e205154c1337774c5dc6128836c85aa1d413d1625d5ec1f70991fe49d5c1b46c1c2b027a5e5aacdad00dd91789f9281b7633b03e249fa7a5ba73993acca728c1fcbbd0c20d5d3e50bd2859f03dc6b4ff7095d8138afefbee28c26152d0126bd46cbd00f4b59173c54f9a4d14166aee8814b728489726feb3a624d35d450e0ad18e75435caabc795bb87b84baab2ad745e2e38529515574503d30ef887c9973b0b22a34c37c985a0b6430befdb612aaa39e1a9a0e7ab69c1410e6d8c66020c1ec4557976a404c333167bc776022ebef92dfb1e7260ac3bfe95b0ba8a5db7c95540de1a11a300b3f961e123effaef4335f7c55d5cc320ee7b55f335a21279759aecd3233ca9bbb18e5fce7cfd7e03cb6031c4f4e2742c96ddce613f83a6647688d7904849855c4915eb8ab94a8d0f60aecf673b7b319d099f6bf29fffd1f07b3e7e7960fbef6c9262783bfd580beb6d5e7e004f14283bacb04d070221aa33df145bfe95f44ec0489d2fb8e35c19b8a8a6a9a6e841fa7c85e956905b9a2955bdddf16365809d3f64c7d33340c9c7284b1fd170315b651fd1826f0eca38b6a52a3437d552d6fa4e5b265bf4e46cf1d99ce2083a6ca2e048deb223ddcd5f4dce826b687ce1e3a7b681ee394ca1f4102beec82e621d4df7f7bf64d6863d10166dcb75a1c24ff578e8c7f7990845406d9152678dbcc5ee79f7695245114c14ec7d605cd7aa82d16f82d8376fb9b0b78d1d9db3e91770e6cae812b0e47cad9d15c3923fe3f09dc2dfd0d7ec5ee8b23d6e21c071f0dcc2ca2e73c558043db92299b05b017e52f04681de2f2e0d6cf9939d39e36d58cdb980953cb02255006f2fe3e66f61ede03e3840cea1d18984d78a71668967841022770853db513f9a5c432c4956dce8b2a8d503c4b853fd8d5d031c0bdc7e43786df155c08d4aaba1ad81390506e899be6b27c9d560ddf7c34c1250dd0d46d44d74b44afa5ef9f80678f7f2896c050e856126dafdfd66964f7541d5e59cf4684e44dddd3467d72a1cbeea5d691382e9d08bb6f1097d5cab21f2eac7050320e7f5c834909143c622716f4f1a3e40805c5825a9b7185d77a0abdf62227a859ac6cc9cfc178f0e9b9134793f7917b9fdcc67e5839cc65ee5481af2d188d25547e3b73aad147e5930864c87c42ac73bfee6d8c37786bbac59de92448312c7a879ebe711605d1d1208f1c91c4a5df5b69c32bc3d9e7b749a925cf94e19b936906c2b6d23c8573ca3aa187d753672ad6545963f5015e709a6b1b50ef2ce14b2374c84faeea016dec04ed1d9a79e86434223d960308004c0de61379b96bd290dc783b309386bbe574178985ae99abc512146d7e852ca7b819ff9cda1aa8129748ab26af0bb6ced2938137ba25db649bb9b53f337896ba502f776319e34f3a0a467ababa5976ba06fd76574d229b99f1ef4df9b86c198c233fc45bf64644235bbf98e0b0d31cf90260213fb1fe050d2cc7454a1fd22e3cfc283d54d42b2ed12823d0bc19f2dffb17b0fe6d62c859668f5c67164452f108c259cb0b1282d9b389783b740b3c1affe58edc3dad163e4698e1489bc65f28244073c8724df6a930816e07cdce7568886f6bcaaa565dfe0919f67e09b1bcbfbbf46d94f4f110dc42c0e89a7b5ac69a3acb64e99aed856b0de6e960addfb6203a781e6780b0721bc250571a8e563aaf79de9decb99e1cc4337a812934d70e11472f6127cd5a3df2bfca6c42352a1e2bebfd8aedee52fded414c90ba76a86ccf7d78847d1b1068fa2389e3cc23bc9f30b7c28432063e3dc30d8eaa9daa344195daa8a862978ef6814e795411b47a0e21d3728548d0044e9e68596dae4a4472c09bd1a6b359d691dd3d87da60d6eccc965e8946da90004d140e8265b4de1ab42e89c14f8ce2a03ee502ff0a27aa7249b427db1f4dd8a2c9432bde7a461bea98637e769b5cb1d30c5d6a707f9ddffa6dd4ac2695f9c92da1e130bf31afd0f231da2526d216ff8654e89e30cf1e148af7dafb6dda8fa654f021fc9a183313a6870100d1c27b36e24be8ef62c2aa81f37dde49b78d5c77b628cbd4d6cb248a70425e95dcae692bd0e16006869cc0cb4301c381a09b4790a0b70e28a0c55a83c7f893c86652c32847ea23d1a5ee226bed65f46f59c1ecab5d9b027d8f59dd20caeb8546e7dae2e96dfa79adeed4258d664ddfde173d639685910994ee8d42b2f3a8a2f5c321ff2f515950aa4a431c1ba1a2abf984be72c23c9a53bc46a5128ada8353a3d99ba5f71bbbeef273b1466bf73067dc91c3bd685fff557090af4915d700690ade9594ed4ceb269e8ef12640d509fe571766309d52c3c6141c81125a89ac507ae0d5f3a552a86fa0490610eb37d7267b2f4cd9ff700d25c3fa8d5fd6257af630f73ec1edb54b44b660e1784c7d7df99ad37560989047f316006fc9852f896a3c21a25ea4183af9a283e72c9c31964a5d6a972e3270c9a1320869b76fbc36b31d22c2d19b8f85c39d978e18fd025d233eef46877c9939f0db98eff25dd55db6b590d1202e56013c48fe9ab11696efba4302771974631c98b36fe1c13e8594a350e116d8d6883307707b58f7501ab046a941f92f0766226b6ad37d4a8643ccfee0bbdb74c404070c63d9cc2e033c2a0d83ca2837d1d5edbec318788d12d330d80f303fa91ac4cafa48d674b5064e7d5dd8b4543ad4f6c18a07d6d6859a89225f0aa162413f86d031d937206f57ad9f208cd068e8111d9af5d042c83127f47f4aee05e925fc4640224c107285c2375551d8edf309f23ace2d8bd63c41450cd2e8ebcf5dc028aaf2153d3ac2b32eea1a5bf7f4ea156b3e00a39a4a2c966cd16e79a390999593d9fb3a8d3bf2f6161ad0c6843a2e90b7f208d18379124e256580228d21411e2843b6d1e7fff12100ea7306e4fd358878cb148e08d43634f53910ce7b7146bb85e3996c5bac41bdbf9a6b33a62a69cb3faa41d822d4c950e82162e93eb497a1090a39c08157b1b36519d11cc4df17ca35d3ff633d19bae384df158f125534a92ec1b6a40ced4c777abe9e18d0ea18e77f4d027069b94b9e33d779879f6580f5ccb29ffa69fe0fcf12154a01ff4ac3d7f19b02b306022b616d62ed6e2c36763c9c9e6601f7f3bb9ca0e86bf8ab64d069b775cd0900f7c1f53eb39adf2650ba1435f48b71e6b46537c24753b2004b468c5552d208bf06c92868ac19537d328020dd7f42e4ab58994767ae88143dfebba17a3c69af1f05fd9fd9e76c7d43cf97b5ef71fb5c92c299420e82b7ba104ddf0734d9d228e79a0007231ac297d3863b8cf238027efdc0438834d4d58cf21f0710391f8c001f37bfe1deacc6d8a9d2b238ca4658835bf7bd8c24e469e8f69981f1fc0ab56663810a3a8f58afd2088747be1e9efee6b6e07e5dfca9c6dbedbcb12f7da5b54d8f37bf5e4d8e7bfce8f008a2e8fe0f1f7a5c2a4d7b8afcf170e22c1523c5e9b5825044a5a4f874fd9cc16af455b529b8ded4e0634cd344fee97eabb22b483d8ae7b01eed88019afceaf36b80d161002b23e5c83f2ab4dd7127672379c151244b871758447d8d0154ed20327864cb49b2a0580dcdb5670238195f6f09e9896106b3b01ce31aa5df2fce98cf515aa37d6f267727975be0e9791493bb9ecc95a9207ab5d55e07c2c816ad6d059d0cc8e516e1a62ddc6c8901ef7bb9a27ae8266d3d2f8c1036f57411900b510b3b8e97870d6a143e837936d24f7ac110770dd7d4224b9adbe8f425514cca8ee0c6565f379763da9ead6eb4f7dad8abfa273e9d5b6c789e857652dc951b0c0cf70575645e6e6a150ad71a3fa1ada977f516e6326cfda1b98605fa6359879d58dba6eab6e7d77e4f3260ce4451199f7ee3e2a225de02abb39bf81cae38a16e3d86801c2efc576db84fe5bd87d8481ceb3f4d2647c97b980c62f9af5f6bb8de5a78b2d47d8ad97524c454fad13057b3afd584d0a1c91ca02caf9fe5d89ed39949f99604e1e89ef07cb8835b7d74cdd9afc146064da3427b9fdb9b88976f0a42255a8e7884e0d817e8c757f4a2d8dc6dd67e279f1b96a2afe6f8e14812095daa7de667c73960a177e485356b640dc5681c2aca5f5b026e11d59d7153dd46fba1c7b53e0adfb662e3c62ce56816eeb09daef85593a2ebbde4fb446172cc95c714cc9b005dc11a9eedc2310fe2664ba6d896c31b882198a4c5027bc2f2ac32aae5e086f892bccac1d6f968a8b5462cb709d8044681fca458fb5cb0d4f3284180a6a473eca512ae271e6710e5211a94805119c1dcb83f96bc1240314f7279fc548b929dbd70ca67e0b258ab0b0ec1522f531eb5ae280baeecf90e5195ecab5bfa040fbc48e93328eadfd2fb671a4b8b7018d89575d10253b30c803dd9855a3fe6858185b6f16496d24524a022c0560a5372ea209be0241f866d896adaf58d829f2d285b765de2e7b5552d580faf8849fa00a63199c6a421e16e34457a210629260430b138b6a316e40d3663ad82a774469c281d7bca3fe1f3e4cc9e8875eea1a80e36e9151042d9f64c10607f6f64bdc5042ddcdbcbfd9d48587bdf80249b517fd766f4c2cfc68021c8ccde02891505593a6b060a10a4babd46dd2c7d06b52ac517b07df4d1dee75a25073f9b8e85783d60058e8839e33f91d7e212bdf98c9ab5c96c084f46729ca24c02af63874905f913a1ffec1f4de7c957f5c6ac8e5dd23f41b8104a5a32cb83ea6270feab673c06246267353db9d670096be54c741bc99bdfb1e958acd9b83adb53b711f36c485c718754d6e55c0997a005f6a605ab2644ad3e93dfee83196a72ef6b7cfaeded8fb21550ded452291932d6fa3fb68d0591c6daba0bc92ec9fa6408aa1e57c188d5e09bc38ec603dbebb88aa34a9d71375252e5f75430a83d54205082d7492ff01bf54417f79edbc6ce4230eda8934e74c81b210741cdaf21c90e39413d1d7f0dd8b3af5392e9e71fc3a8a070f5977f6a6c165124d335c4f7303a4b2cef8f1a27040074cfe015d4823d23bbf27e67f834dd1057ceb7d98a275f59718c8d59e631ac69a80aaac1cf63d59d1575aafee4ba995426a9614ce8b6396b3d488eeed08fd543378b0c758cc549d1e91cd2541dce8c9686b90f35886eea11acef82aa1bdd04604867976ae5d9808c9e23d0ef0b4ed9f41a7a7bbd6c7f8841380bbc327fdb81f902c880f228844f7445e6bbc5ff89d0f195bddcadb6320a20cbc8493d9ef0d2ab7efe4168fc1e0cc199c33f32313d61e8ce5d8e45860ebf558b5aa1fc0cca9e4170787feb32b864720fcc22a56f2ce6d09699e774b026159c1e5dfe7f13f833263d2cd63bb026f469af49d2c860b6ecd131afcecd16f41f3c1f2d6bf23821a1ebdbfa7a3b1eb3df1fd4aeb1afdf8d35f628de7e7f9a2a44885c7bfe1f56ebcc470ca3f49ac5a60e8b37987bb6842e0c12af75ad4785f153eb7904b8de7b67110121072e355cf4f5309ed91e5e6418420a8a725730c632156efa10ef0b868f3150847837a307cf98b16a63cce4047157df0004403f3e50b7170fb94de91bee07ca4e4184c82f5282330df9542a0b9138f2213999549ccf078311f0787f18d28155431a909d1a3216c8fde8bf297cf049f134e361c225d11ec32852741bcf8f928de1af2adb93f6bb0e91dd78d9b099a8d294b612d92fbfc24bdcfc95d0587830b0c3e8ca5eb69de934d6c91326c7548680e67c630a6ac7d508e4625e37cd3f72d2b7d839f39f35adee2ad6d3cc813e5eaa283131c966541e51227f07ae9027bd5768c6e7d1d208e6df7882d604781339f3247c9615d6215d88e52521853b41ca19c512cdf344196f1838bb6ada5b63ee722f315cad29d9caa8d45c101413cc08bc9057af679df8c6b2daf6b8c1eefdef2d0d39538d228d565fa29e362addcf65fb09a80e4af32774578a51247988a1b71da59058555aab82e5881890de438f42c0fd88f2bd07ea87a5e0ebf9353102122f69833fcc0ea61bb25142124b24d0f86890b3930f258e3886d613789fd315695c2bd9e56673c1a41935ad1ab552c0def09e866abd69cc62454524f7b05349dae69e7c7868f7d222c05dadfbf72b8904ffead6429cf52bbe4c5a2705f8af83d64f2ca4e2f39353d55b468ab7aa35fe4e50abbd091ad71dcf61c50b9f08090dbcada24feb162a1c24307336df45a41c3d6d1341ae5b639fcceb5242f0869a56382cecf618cf518289d9605aa10e854758c17152b897a1513988a3d692b74f6dfd82247372e713108c84e7a7f047a96c60f13d5877332b1c8763d977f146d6fd635440e2081c8a853f9aa6c1e076a19b0bed6999d32a8ffaf9ab8466b187bd0c6b4dc6f9ff224a8bce34127271ba6a90faf5d1f6218ac5e71e920a0cfad08f051989597e3cec31fdd16b20e8955241c1ed2af88fcf837c165c2f0e96733841a7fdb351b23b110beb66e1cb0d830df7b072ea90414199cef64a4b71ab262d05bda659a7c041d9eb4763e91184a9909d9f0aaeb01a6afd6cac9b8f5e5820ed3654ff7458c83761850819cc3bed9b9913a399ed09518eace93b9d542006f4adc9c95f6eaa8b431da7e1c42e05a6c3f8b61c2f39abe88e7dd24f7f957c96e0b427c4a737c46e5d5a1e1a04423ae66e9ab2075641e40fa5b5","isRememberEnabled":true,"rememberDurationInDays":72,"staticryptSaltUniqueVariableName":"5928fb8a15835248566c292f88e1b64d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
