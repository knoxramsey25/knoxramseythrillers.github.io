<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b992ff2e9f6522b07142defebc946055fc369313a8784090464c02895720cc3e83f908dbf68d73dede3d3eeba424b8ce99e08706bd984873cb8d5da95dfaf1182e0c9912d0f9bb65d6618b488895dbaf54117f159c4eddfc3b48b7d086555607d0ed02d7ffbecf5c25065cc8d21e7596b676ad2575e4e043ccab3b7318d09ee98dbd71701fb1b8219b481b52dd81071edf37beb377e87a80b9c97ba949216b707245a34a909a26fddec4072615ae30e1e4dd43c1a9f9c12a1e62a8d46fabfe4e408c3a1e0b63c53973a68902d7ddde6a958b70071b6df01ecd9d02ccebf1937162c6359889cd195ecc77f4892e5ed0a832a3f817a9c6d8a6fc23dffaf951e41f463c1b25ac3936575544e0e376632b4ae9be39468fe0bbdeeb4c29a3832e25374fbada24c0ae372c4efb3d9c2758d7034e7477bd4e6622df1e22d7cade5b5929f9481de0b0098091d07af24d2caaf1c49e73126a46d1fa4f93dfc88484ecc8740d5cd13db95cbc900503d71b2154a090601ea54ed01d8da51c27280516dc5bf5ffa9142615d40e1559f7bd3eca245d0d90396e62068e61f0e45c2af153c25747cf224bf2054705b46fde3bb3812092eb9ed59c32ed38c3d5a6c0ba2b12c9e1084b3fe3e9dccc6b9f645e65d5917edede36aed06c95571ce228693f2efa79501f0812d435670de5a867895e8f37a10a916da92eed18d52e03956078e139a0187761638537b14b47dc9b8d1bdfbe6cf9bc27fe7a61eae65bec33f8d13edfc39f72940f60a46b7491bd97607ac147a065b39e5654857b08d5a1f2e2aa4e2b72787c50dee3cef23082a18f0e51dbf0aaf35f4fb1332ca56eea805ed986bce6ef01b144b6a8e404cb44e564d218812f48028ea47e16f264d67cc92bb24f718c9c35d2077d96fafb7157d894b5cf5fde1291c87b85a5a3f9cd8564bb17edc0a7ee7313d1dc5541babc9c85666f54ff583c2ebee70aa9cd3caba3fc3b9fde656710aa8e34c00bc3e642dc4080d6e5522f172c6627d0368298c037d24e890e093aa9f38579457f87a88127d3eba3dde657709497e67166063783ae5224239c7600af4a358a37b3069ac4e8e8ababd520b383dd627e23209f4407af44a33c54b75841004c75bd92c3936fe6b8f8fbaac4eb492b2fd410992442f15a8452ab82430108dd9499bbaaa9c526a4744c67647a82ea51871cec8fb77650310f511aad2d2c601a25164ba894cee9f9b356038cb253dbce6c19f377e6404801dfc6710923c5936e1da7677fb91075b7bbb240195dd47a500912ad9f4b5a7e24a723fe4e66b9b895da7f392f6c51121e2620eca2da89d9ba5f407496d3d26ac73710b6eede248c1ed43b9a135cc9ea1c4df65d444771f8f9e4939f293dc396ea2b68517354f6e2fddbdead779e10c55544b62c7bf91e3fca53faa5b60634933855e7e22d6c9ea09418609e2d4564da05dea697017a5f37f179e0300a4e04e859cb81e5441f7ed041d64c1a6f86c4a14c7d1a25079c80fd54a253bbe1d6ab1a6613f471b0947e1e325bc2ab92f62fe5805c5726eeb671d0fa2a2665e1f0a418199601d73d6bd19f086d107a095ad01c3628a86b64c1b922e1254c08f1143ed2941abc158c618d7d2d18c5dbce5c05427b2b51d0e5b9222a433f8fabd8682a8982234e914e0cbc2e25795a4e236b52ed97f34f09d50623cd5310f2632b53e9a2d4377fec6687b3d0c975313fdd7933f9fa4bf82bdb2b0d1e5134d3d23c4c0f7b8ec6aed424819ab945c143565b1298d7a2ebccc23725fe7556316a0543fb6460760b90361f472186a1ca2a2280210a18e0e8fccbee7f5f8558437427729758f87d1bddf04fb6d4a2cf4db09b1b8561d274cd5284c6b7e8e215c349508ddaa41e938303acaa1116a579731a2bde6596b1fe5ff128cf902c0553b2780d80313ab7554c8428a0c0317bf9979027df6d83c12bd6302d1d69486d585a41d33dd48e5fd8498e116623e073a98dea845a332c5faeb2c8b64587a6638ae7f5bb8b2b6a77e33604e06bc29bf9637e34b1a4e09184109cb303c836495c650d28467a6f711f98c48c44a283adf305e2b16ae398b5974f737c440b3d679e099361207be3662eb6a7a77cd9e9c22004cb31e137257f6d9df1468c1123eb433ec252415525ffc37b16992ae174d36b64f4987387c5952f636656842a9a6d3095247f4faaea6784493f949061c05aa37dda7ed69d5b6ef85ca6d2aa0342103af96148c5d538863b2b0ed5e3ddd83154931216c9ae4dc047ae28415bf62c012832e1a7bfed0e844c3fc7d1990a7770c0132de2166d02fbaa44459d1f25c27767a43d6c3522d535ca813fe353716bfc160e22704ee81cc480586de61a49fd15c04c7c88ebff81e789bc8ccd33157f35c99681f2dbb3429b6d128ba3461d5cbc7a46fd49f0df26d6afcd30a16cd71abeff4562da41287866c408e36c72b90043542cfa384d96c691605962e9b72c37bd2ad29ec1a9ccc831d584577e4c47dec2f789f56b048942f87d2c4c0ed986b75b0edf73e7f6c1eb2e306703e319383e4535256db57bbe40909ce6d68fbd45505410d596db54bb6fb60365a66240ce685f57ceae14baa8bd345cc519c493a5e97fefccf5f19271a681916b7dbfe18ffcb0c5202d72fbbffe59beb2db4ff24b8319e17c128430b21c8577399929571954d8d852484d1583fa1a443d4672b69204fb01a143dacbcee184f84af414a6a59c43ce14cfa78e52de7a5c4ccb3986e4b7d36d3e1d223695d0a89bf770f2d48a29077691aa57c5281b659f632781a0caae434366b19a85ecaed91f7d3db83312b85d9c07d6069592e19f547730a46c0449ddcb6fd45646cca30262d33998e6343bd1cf69a36379fc09906ce80b6deacbd2e646302d15d64bdcea077405ff3d1b9d6137d150ee8cf593b862e0b39d1369a2fc587d8f15cbea015dc6336ff218105326d3c0babb65a033eb4365ac00bd7a0ab5a2d95a1b5bb4763a82822e87ef7fbb339359390e5cb1d012e9646f6e399616094225dd8323b39195af1324fc4a2eb3b51cd4ec232a0715a69d7f912cd09a25a5ac33d0f00d859be9539851d183372717acbf93bc161fc8546ed6a156bac66f000917d09dee119597275c6432356631d9c34f574308316d7262891ddf8693ed2975e6bdac0f4bb1a94d84fd8bdc4a2fcb4c1eca8d94bd9e04b96f3aaa5cee1777e9390f02f3cae371fe919b2964f38a054bb2f4d1a285744fac3b924ec96b9e1f7a65932b7f70df984a19d1c68542fd4808d9e641de4f3f007368a171e5eda05bcfc9ad0e7e59f66ea983a4ddab2e2a6ed3fdfb327582fe621c297b30c0d4e4e3d22ca5ae01a1f845a7161e879c4a9bf8bfa12a0b387db8f7117d4722c70483e2352ffd3e4d579a9d12f4b4837945c745c7c176cf676e87640ac1c1b10338202657a25d4d94215841bf5558a2e88ff7f5ed38f07414496dd829ad3d2aac33927d058748d872a423fcd9f7f20fa4cd817b4ba379cd44023ad250a76490e93b937613152f46e58383aa4746d703352922291dc9c9f166e76c984261b656c214334dccdc9e3ad4bd8c7b9d025bd602a3d6ed3ded2686151e611dbffd996119e253e4d1e36c45194713dd3b52f686148c42f372d9ac3ed1647c30d56e4d0d91f611bd3a5c2f2c494677f6f132cadaeba482555e10db2a258a1cac77e47bb9732d9ba545c498fc963f8fdc5c267c299dd3007e5caf3c7f539ea93ca6f242818544db16b4863f890f88700b14ba0f9a33e1db8fa25adbe433d7c8e164bddf12f84f274dd3af8a04c45744c4262982aada91eb5c8fa8fc8482dbd84f5fea11e2ce150205e60b0ee53e0f1862d09cf8d2fc1dace72dbb5249d8b4907c95a9b00bb4df964071f5f7b415fb065a629b0b0d67ea293d02a4578017b1f7361d942beaa99f0ed3e1d7d934c1a77292de5411a1ff9d4cdec1eec2d186d32f00791ee7298eb354ba8760de54d92f22f3aa938fb85263c03e9af527469c955737a1bdb0a79f69a559e40ea46cc9479333fbf6d73eca1d9223e499b90d4622f848905ae7b05957f000eb4add53d53413136c41d5d59d0a97303433dad6723699c1294d1c67d17e5e3d19f6e1b7a221105c2de039e61e06b06e7cd96e89bb107edce687133f615a81f42d1176db6c57638030c2d1f0ecb3ea19a486448e42076c46e21e25ee06c77d8132b6d199a0cc2245d47664ebda3d704154bcdbb7250920650a02c39567bd3f0b4d5e97228648202781a376ee0749b5091ff9c1931bae721cc832dfebb0673c278f87a3414bac9d423d7e8065c4932346d93a60cefe1e94b14208c7a32f975a4364249dadf5256287747e4d2b00679de53465d432bcb01aa847b3e65acfeed054f2a4bf153009c7b78df96cc5bd5d3a0fb6e4ff1dac4a13f73a4e69a195cfd8c35e6ae7ef805bed5a042328714ad80e479db9493c9e0158aad821b7ddb7d28bff12f4ae99cd65d34dd3d36c5c00038189235a8a0eeb8fb4d0e70769626500615c553744f43d0d7080fd92338b1af1d1d9f015a214fe953e9ccd721b7f4ab4cef98492cb4a64d4a85c851b940770a855d9560e8e80b90df4d959b0f9b03e0d7b0f8e8561893da5834d191cc3f6125e6b3c4fc8aafff88d8fa099712b80e2675ce5135bb12ac7010a1b617face95bc401b3b4fa44e743c8135cda876cc3052b69ab1da3760eb0bc96b9c369e65e5108d01d50b9da690dbe6641d1580ef620a70f42eb010727e0adff65e0c098925be2cb255d7ebb689f35ddfaac6d83399ce76a25ab949ba0c86f3e7c5f9742d2a3fb56eaaeefd160819cc6d8d7595af4d09e623c83f1ac9810fe6da24a01d810348e716ed601bdb1705745777cd9c308ceee83f26a8b8289937f2210f3412cd77717a5135261251e58d7f84ed4199fddadb212101b0e02633ff9870d14466df6fa768e5c73cc89c6dfcfdb91c6de91c575f7b4a567e074e3249b32d060aab6b26a58cbe441dc9be89d38d3f88eadc620ea7805be8796ff4b79df80b988d63dea930eea6c7750a78cd1f9ad804212460ef63e7561aebc2fa3746ba04dd0b4d607dc815e827aaafcd872784209f51655ee08aac0cf2600a6ffbac1cdfd86ec4fc97ceac1c0544501ab4ee87d1c98833c97ca4121efea96708b467306014a915d58093139356f1833fc1563bd669034a7fc7a6314954133dc1eb19a1f81d9f8bcd7f34dfa794eb644f5fd8e35dc5fcf80c0a53e7228b506e84e563fab893866e542b46d929a4a8ba379ff5ad239bb8b21cb7b20edd244f4c08d6c85dbbc70829f01b3cab14054cb9bb53df80d63527a35308787b8766e0993cd5d930330fe07f5dd975d5c0e81a3700541c9694367fcf0f25f80f5f121293a9a35dca14a1c76a10df1bd4b80650acb6d234eb902049e61aa84acac679cdd0649cfab92ea376f09c1f4debb73e6d7396e3e072adb1c1020d995ef8cc2389aa5198cb4a42eef84a9e684be91698ed866ee590b7e4167a96065af316a6cb60d6fe0cffaa9c14b82fc88f50e349c6a206668b564ac64037337c7243f6ef9214d7d905cfbae0ac992f7146aaa149c406d75f5aacb67ea99d415a824a8be06d2c467c919e4a7278cde4a6663178a79c618484bede9aef453a71c7863d5ea0bf6e2dbcc51675ea3f9f651991fd60f249354e0bb916f8558f7cbf3ee943aadf67aa32a2096a91126206b97559a2c9dcefd87cdf42ded9f45ea3c298a9382d49837efe4d458704f72d176ae6e4d74b9b2064e7717e000752e15fc2def42ab9bc9928726e956b56541980ef2fdaa5550596fb5ee05c5641646eb3bb75bf9b3a633d502087cc8eebe2f6fa0cabd5a9c5ee96d67dbb61b054409263113bec6392e6046c3b6626b8b1c01a66abf2d2d2a3dc4b1962cb7d118fbdadbb5ad87b5569414d91d2e27c28087c206fac877f9694cc75bbec0890cbaa4c0fd8343a3d5360192fefe087af1f38beed7f47656ac8e821708faf4733c21344bbd63cd89f7769ab238a9c3025a26465c1015f1b051054d39bf90e8544a970b17b2377e55b70c08042ff0d2a6151dec3f26a73ea52e059c4b67740077f6fd814f3f9c13faed5dd41da3d3776f35df3bb1ad7aa1ec9447f661581991d4b3c3c2b717757ef275770797448fbbbac800db3262f161aca20defeb5de0f0d805556f118eea3f95c21bb173077ebe024fad500192368d3036add52aafd35456216bb7600488c303d3c0974864766d35847c077a5658a0261e89de3d2c24a990be2d0190c33587420ca8f4d463080fbb0eddb00769d130b9ef8b5442e811dfef41f95ad5f3e5297765d2e66f531436cbd964d84147a4f41f45ee31d1c004bd381f221d7526f9faea157e58b0f0c68ea73e029cbae9ee90c7933f2e8f9ec10ff6082cbe9193864c2eac609733a43f52e633835bbb84f4f0f4ce917a5bb4b6c40046ae9e340008e31711fd957255bc150d7ce53cca8c19ccf34a3857af7c9d616f6f178e5ef0fd8adc0cf2a9946d570b7ecfb3a224b1ff6ee6188c215070e80847b69132d38237adf775132b30ec2be3348a039f79a0f4782433f6f482d4123d6e9b3e0dc25df63e2916c8a486432f1a2507a4e2f02569c8eb7de784191ab20c2c928e61b4824e0b920c4128ef2f44ca486b591253139193954734dab0a3f5af8d5898d9864265cbc6d17d02a1c7ec51f2d6d2144500d96d1b66b0d661d23595876f261f4adbb0899fbe674cc1445d0f3b15210bd5f48d3d973c53692700713b5b94162d08192965c9bb05ddd231a6c7bf5e782be3959ed146584d10a102c367092665d0dd9ee40fc7517d013f8aa834ffa7974ef4c21a358ef431f28d5f37806674797a1b3a1841e2c6ffaad2f17d331b94daa30205f56ddb46d7c9a2a536cfebdee5f18cd90a2b2b6a5d84a09872a8c5ac936e9d1048b09ab451d09aa757245e87b3d5411c6e1f7ba14b6a4709906160faac5398d16e92fedfe13568e742aa0049cc102ab40d93b870d163f383d7590164e216e4bf1e5a1b3749acea721954e6403ae03d4815dfe8dafaa335d61e4126d2ea26b2c711cc7d15ebf6728e8b23e4126c00c3ebc3789c78290489fbaf6dbe647b897d7359279ccb9bde1ec6733c7e02bb44d67d78d1291a61241175853955b149d37724d0b8201fe64ac45e496984611d5381d2175ab890cce775579c6a8ed3868507734bf775ce740959a1e58e7ae5aaa4316a641f7e34c2e54c8fe10c941228d69a7bc84cee16f3bdeaca5a8a18b3f1dbae185720dc8059100fc64a2988b80fc2b619a2fed96f6b68da0cdce32fb9d55cd7a3a99c50c58c69a91ee6366591a83fd549bd85055dafe7e5aea2466074cc98611e659f3c367f1cc90a5443d3dbc58eaa611c1ba9e537ead9bc8c08db41c4083a8ac98fb8340802f2133ac536ab837ea7176482596bc30f5efeb53a64fab8a76fff1615c2860286ee27a44b86b6320973defee90a0fd8bf74ecabf0d026ce1277284ff2c1034366acf83f6733d6aa2b48e01684913fe7c8d84d7e2be2679c8dd3461c29e5c52093b4def14778fea3e39bd14faaab08623d530a62bc01228fef37160ac05b488b6f3bcea8c02f2692d8388dd326fadb261ab210fb568712ce51a49fda6c5e632aac4b658a344fd4e0224bd93a540152c3e951c0e36c2492deee6a9e917b6b22a1bab396ccce93032da904b8bdc2e22b55021bf7944beac5edd80adf9831cd0011e7217ea4a4dc9c2b9fd35145b9c98f2dfa5ac4d4186c3d51173085c44ef6d3ebdbda99d8b56623e949fff75adf2bd5f51c8281623915305ad6133f1659e4595ad5fe02657ed8660f1f9b054959a76d4a9e0c08543cd85cde22339e8920b41f71e6f1b8bd1b9c0b225bba8bc9ce993c76cb4af7c61486dceda304451f5340a761a752ea976a6032ccd2e83158cbdd507eb0c08288994ea2fbedc82b2898ab5c6f94c83d13d1dfbbaf0af0497bd18ff00705b716108d9aaed847002dceaa7e0aee5f6c1fd295e5d873eebc5ea881d65c7c43cccd64d7ece2270b9507b89bb3556e07d5c1049c9c867c0667163b598803fcf8e421af9ca0ce8dac6b96aebc61d4ba75991e91c9334056a6f67830be60c830b756fda748c2d492a753a3f8b3d2e373c191e8b4dec34190df9076bd38c19791630368896d66b4c6c538443b82a3d93999a4ec2b276c8eebfff56d7514ab03a31806deb1fae6f11cdef197dcaf3f7a8f11069d17df97f607be42666419d984ac4bb64e6f5512e5bddbc9f00d7b5f29cc93bfd93bc10f99af0d0ef4d35bf1d8ac3eb939d0cd308704f367eb3086bb51e3b51285db0e61b808d32990c371c6f387ddc264bba416662b70349abc49fc250ea24a72961a6dea2897c0d49862a4220546758a6f4438f6b49d9e58ef0c68c635bef6197345ac91da04ca4e6b99f6d6c5225161c1f44e5693f1d1e80f7cda298e7b3ad708cac69ce141e726f6d2e446e4602df3db786854092cffeae8e2ff01c7fc279b6fb5375fc62a7240250ceb273de8d752464f56ab01d5b4734ee54d6e17fb95e4fa26aed35c10255a6414a9a5bab9f2133024b416fd847acc2350743feab784b9238107d00ec9e244360b62d9cd0577f1ba2ec12f81ae26e70bd16d06f0d911f225eded0630bc5165aa83bb23ebdb992e9fae2d8bfe2e8e4731c56f0bb8d72905d02b3c21d2215adc605f6c76b9089a0b4a2c535a84e5a89bae731cc46b7a7b3416e9f459b16c181506860a99ca61a2a5c75480e4b08eb7c384f74585426faea9228f644db52c0d50f13d06f44ff9c8b24c170aae1ff876bc9fa2e69cb2959fbfd4b08f0c3b02959d3b789e1f2def754fe284b131cc5f6d4f8519819d0b658f5231821c98bbe80317b612d252bac07f5272f1351e83a91c995e8854e62c1e669765a82238c82cf04b29eba4e66b1a0d4f5939d5680099f04d2deb0bc33e2c1eabfe6fd3a4a0ec2e3518bd29149b88623ab98e4f1f919d340483e5cc6cf806ee61fb7d3f1651f3fbdd1122d3e31699357616254e797c78690426b82ae89393ef4680de05852df863b8e20988284b06ac41f8e696815f415d8c47bd7bae7f580e7a757b2267ac10244a78e77b5735ab481a8dff80bf260188fb02fda193419e2198b5992a09947580ecf3ee16fd16ace58f2c9b62402e0ae0df6e3fa7d0ca210204746ade861db49d257893841e00425b90118a401da4212ec0a9ceb1b60abf031229c7488717a9a8efd500039765c199a410191b94516d25843bbaeb1a0e39af4c32c0415767b2cfa228fc4128ed9fb269383ad90eafb957af53491cd9de008fd9c4e3ba46ee023532f674a6b20a5942f4b73b717600eb8deb2798cd108923d936b5906885d56426e225d6e53ef96a760df15d7f6e00675008c4ebd33fcce6315964712ac590de2fce2ef579ab0745d79fa0a8fde42a174348a283d90836f830c3e0171514c9361d1389cf6c0151216dc7f75b92419fe63257613a7d9a4e0aec784d927672b22350a8dbfe654ee8733dd0902d855e84867b062e6cf13d455f653a23c17793df3d39416d28d7845416f97e2aa1da2f2070310d7994270a843abcb896e6932f2f7ff293870ab14f89080c64cd7f93aa81d45c848e2c367508faaf62cc24ad232efa50b6252002e1e56694cb40d000803e704fded5851645b0b44d7cd51051a0fadce538296f8da1c24b734d6a583a32c26e449c4ef0c8dbae9515d92eb376b4e8bcfe04a72b808e3bada2038705cbec227278ca6584e1e78380b454b624832f27c0bbcd7a230b2a6d3d59d8043f77de5e8575abae3c5936d6371f13b7676f16d4271b9bd2845d5d3d8621aeebc4f3d07e2dfdb7b29b7948a669406d6cc4415671b36761420f6d12353f42f645e49b2b4bbfc5d68b02830a6ab71c6b79b1b1be874f469b917c13fe1b8670ec3d6e348441eb238c77b72c2a97de2bce7b853f36763dbc4592bea7d7950590ce11fd24a2409fa25850be7215c3ebf8ffc0227c1846c4ad2dda7d711c5e1c3715184ecc0dcfb0f365586b372d0ac84d2996dbd401d6a76f1e00e343abfdfecf8b9f20e29511d22a8d0c7b5bea3d5ccec20006f202a02c3ea206e49eb8d662a6156e9b26349c505cc2488fe892ca234806092141b7a34f7d53792829d23c87d2a403294073f33f01a782e8ac01a2dffa58d12ef3d2870a2eba58294db5bc54c8af67f128c8bc8928a5a263052479f8012bd9e161c9928ae8c94131a6dcdd6ad6ea8d3c4ca91175d6297c39e3c07ab4c41249922c0a5573829f79dfeb484d76fb6a1ec1fce5f5934f0df048a38f334a00518b0a553c8a254800c3c7b41c86e294a9061ef9291756dd53335da119ea979b55f46eb33d96bb685cd284f3c5cde679e8710a5aa0df7a22c27cce7de0568a796ddbb338221952f81bf57e4c05f2f1dd83b26e7fd1d7a0452297d3b5719053e623126e797ad7daa705574ebde3bd79b971a4f888bd6a0cb2bc6188a9416be6449be20f1e0e46d981146f8a3b9e995ab7d5563193bb69f92b420d2b3ef772ddc41c5606f3098e1d038b1ee5ec7b77a9ef0085003038673736d48831e8ab5826a1da4f7b84bd990171a9579a464f9567393eb1b2531e3cfa0290d2c0de28d7185c53376f48205c3e92da173b59c532604962767715de8a52e9d2857e03281d88e28bd3c7af81a117db11c0df4d92d1977042cbec6f2f99c351457a9b03a57869fe341ee7edb54652619b1ca6047d44fe62661bd415af911cf154ca1ac1b87399635e1e1f99eceed1dec4d984922cf992a43e6c375f907eddf3ae53af1a04dcdc491be85a0bcdaeabf57a00d354354f8cdb80e00fcfd47c807116f35f60dcd0bc7db6ed489b4cef0a0e089c05517e9c44340143f2559df0bcea39ccdbd7e0a66042ea375f383beec05fd2b42f3339aa44d7bde63f9b2c183179f68188e3b8608a25e0952a6076992bed3e440d4e2566974eae49ce0f3c2a885866e5037062c28b368d2c856c14274144ee5bffc76a48fea9d93b98bff234be4591899cce81fbdb8cb7016a81384ebdf80a3943ae673ed62a809cd6cc41d17e51fb9a7c257011f2109c300d87e5b5fbe544d5055fe3089073633ba1de17e1982fc9b02612aa723b4c5e498216bf7d42f78d4d7d4a86c465b1e697db0ce2f569773f71485d745eaa48d232ebd97ac30a0bcbf49c00698665145e4629bba11e78d9b948b8eefcfd88e4711298c7eef296d6e2b801a498470a0562f8d6352c88dde818511abdba5a89a8323150e8724bc042b3afe12823fe524f54479b2226b4af448198d1275854412ea44be9e9cf90de22841a8c3e2c247f9c2bcc024e44056913d00b432ea46f479e354d490795571c2ce6bfd67268f69e2ca81b3d27e2ec15a52e6ecc31d0c713a67e0a0c6b1cab20f1940945794e0419fe077186a58c1a5c8450fb202ad888b4b24495f5831f1f92c307d523acc964df0d4d54b468e2ffadb8af3ccf4ae2857d1268dacfed061a24ce5347e05c3765faa2674bb6d9ad7ad8fd32d1ca218937be8e9a78713c4b236d17fc65df198dd545cfe1b81af118f7375895896ebbb76c667bc7c5b1dc38c214d9057af2bf2d99e624cf779f012b2db43c08d2f3db036e90bb79958108056e8def2df2beee876809603816015a555835d030690ed6d98b0447fa3e7ccb24117a14537b735c86e25d20297b8db7d3d8e86f3f682156a354b0da99f23314f3dd81cfc05cd9db0c26471c32b0b0479e877b5a1af95967d42b2ddd1df58d358b6cb35c087a52ed3792c9cc3e613807d273ceaa8afcc5a301560573ce95bfd0658ca8953f6fe40d3863133759224c6e79571d016ddaf13d7a5e66455d352ed6c8174a97a4a449d865b84894dcb570fb57dbbb5a4e2adad70412bd641d85655a07d9b0d8338299c95a7a0b9e2fa419e2e1ba4f630d82a244c4d8bd48e0e101343bfddaeb09066c9fb0d7af081bbc155d0dc0d54ebfca6739c393e21f7ae09c44ba103797bd5d9942e5e62f1cd7090128939d8c66ffb9e3b027b114ad67f9b017a8ac28dbfa9392f2ffd2082aad9a05fd08ec652114394a08278619965df09","isRememberEnabled":true,"rememberDurationInDays":72,"staticryptSaltUniqueVariableName":"5928fb8a15835248566c292f88e1b64d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
